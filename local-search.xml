<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程笔记一</title>
    <link href="/2022/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2022/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>Java个人学习笔记</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>甲方项目提出前端页面增加一个功能，需要将数据库的100万（百万两级）条数据，在限定8秒之内（用户体验）导出到指定数量的Excel表.<br>采用方案一：C++或者golang或者C等等，但是后端技术栈是SpringClound微服务，这样胶水式操作不易维护。<br>采用方案二：Java操作，采用单线程一行一行的读取后写入Excel，那大概率会超时。<br>采用方案三：使用Java多线程。</p><p>分析项目需求 Java多线程不仅是实际项目需要的，还是面试笔试重点。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><a href="https://blog.51cto.com/u_15773567/5722534#:~:text=%E7%BA%BF%E7%A8%8B%E6%98%AF%20%E2%80%8B%20%E2%80%8B%20CPU%20%E2%80%8B%20%E2%80%8B%20%E2%80%8B%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83,%EF%BC%8C%E7%94%B1%E7%BA%BF%E7%A8%8B%E2%80%8B%20%E2%80%8BID%E2%80%8B%20%E2%80%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E5%90%88%E5%92%8C%E6%A0%88%E7%BB%84%E6%88%90%E3%80%82%20%E8%BF%9B%E7%A8%8B%E7%94%B1%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A%20%E2%80%8B%20%E2%80%8BLinux%E2%80%8B%20%E2%80%8B%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%87%AA%E7%84%B6%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%82">进程</a>可以理解为运行的一个程序（QQ,微信,网易音乐,Word,运行中的SpringBoot jar包），由<strong>PCB（进程控制块）、程序段、数据段</strong>组成。可以查看任务管理器重的进程如下<br><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B.png" alt="进程示意图"><br>一个进程在OS中的资源，包含了CPU、内存、磁盘、网络、I&#x2F;O等等。<br>OS支持多任务模型，会有类似上图 可以同时运行多个程序，对比<a href="https://www.zditect.com/main/os/multiprogramming-vs-multitasking.html">多道程序概念</a>。</p><p>每个进程生命周期都会有就绪态，运行态，阻塞态，新建态PCB，终止态五种状态，但前三种为基本态，时间占比较长。</p><p>一个进程至少包含一个线程（主线程）。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程的运行开销重，为了更好的使多道程序并发执行。</p><ol><li><p>线程是CPU使用的基本单元，<strong>由线程ID、程序计数器、寄存器集合和栈组成</strong>。</p></li><li><p>进程由一个或多个线程组成：创建一个进程会伴随着创建一个线程（主线程）</p></li><li><p>调度切换：<a href="https://blog.51cto.com/u_15773567/5722534#:~:text=%E7%BA%BF%E7%A8%8B%E6%98%AF%20%E2%80%8B%20%E2%80%8B%20CPU%20%E2%80%8B%20%E2%80%8B%20%E2%80%8B%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83,%EF%BC%8C%E7%94%B1%E7%BA%BF%E7%A8%8B%E2%80%8B%20%E2%80%8BID%E2%80%8B%20%E2%80%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E5%90%88%E5%92%8C%E6%A0%88%E7%BB%84%E6%88%90%E3%80%82%20%E8%BF%9B%E7%A8%8B%E7%94%B1%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A%20%E2%80%8B%20%E2%80%8BLinux%E2%80%8B%20%E2%80%8B%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%87%AA%E7%84%B6%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%82">线程上下问切换比进程上下文切换快</a></p></li></ol><p>创建进程：需要为进程划分一整块完整内存，需要大量初始化操作，比如要把内存分段（堆栈、正文区等）。</p><p>创建线程：只需要确定PC指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。</p><p><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.jpg" alt="多线程进程"></p><p>一个进程可以划分为多线程（并发）的重要前提：通过线程之间的通信，保证数据<strong>原子性、可见性、有序性</strong></p><h4 id="原子性（atom）"><a href="#原子性（atom）" class="headerlink" title="原子性（atom）"></a>原子性（atom）</h4><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。</p><p><strong>保证原子性</strong></p><ol><li>synchronized 关键字定义同步块或者同步方法保障原子性</li><li>Lock接口保证原子性</li><li>Atomic类型保障原子性</li></ol><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程修改了共享变量的值，其他线程能够看到修改的值<br>JMM通过共享内存实现线程通信</p><p>volatile变量和普通变量<br>volatile变量强行保证了被一个线程修改的变量的数据变量，被刷入内存。代码是一样的，所以其他线程也有volatile变量，但此时他们的volatile变量不生效</p><p><strong>保证可见性</strong></p><ol><li>volatile 关键字标记内存屏障保证可见性</li><li>synchronized 关键字定义同步代码块或者同步方法保障可见性</li><li>Lock接口保障可见性</li><li>Atomic类型保障可见性</li><li>final关键字保障可见性</li></ol><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>程序执行的顺序按照代码的先后顺序执行<br>JVM存在指令重排，无关系的数据之间的初始，是没有顺序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ......<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>        a = a+<span class="hljs-number">2</span>;<br>        b = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(b)&#123;<br>            a = a+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上述有多个线程在执行，因为a和b之间在A中执行是无关联的，不同于B。 那么在A中经过指令重排序，可能先执行b &#x3D; true;当还没执行a&#x3D;a+2;时。另一个线程读取到b的true状态,拿着还是a&#x3D;0;的情况就开始做a&#x3D;a+1;<br>解决办法：使用volitile关键字 <code>public int volitile a;</code></p><h3 id="JMM-Java-Memory-Model，Java内存模型"><a href="#JMM-Java-Memory-Model，Java内存模型" class="headerlink" title="JMM(Java Memory Model，Java内存模型)"></a>JMM(Java Memory Model，Java内存模型)</h3><p><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JMM内存模型"></p><p>还有部分笔记后续补上，先赶项目去了。。。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo本地和github文件都更新，但主页却没更新问题</title>
    <link href="/2022/09/30/Hexo%E6%9C%AC%E5%9C%B0%E5%92%8Cgithub%E6%96%87%E4%BB%B6%E9%83%BD%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BD%86%E4%B8%BB%E9%A1%B5%E5%8D%B4%E6%B2%A1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/30/Hexo%E6%9C%AC%E5%9C%B0%E5%92%8Cgithub%E6%96%87%E4%BB%B6%E9%83%BD%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BD%86%E4%B8%BB%E9%A1%B5%E5%8D%B4%E6%B2%A1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>基于Hexo,今天打算更新一篇解决Python调试博客，但部署在github的个人主页不更新页面。<br>逐步一步一步查阅问题：</p><ol><li>hexo s 本地显示正常</li><li>hexo clean | hexo g 正常</li><li>hexo d 上传github显示正常，文件是已经更新了的版本</li><li>浏览器没显示正常</li></ol><p>从上可以发现是3和4步之间出现问题，对应查阅Github将上传的静态文件是否自动部署成功。<br>解决办法是可能只有干等</p><h3 id="定位问题思路"><a href="#定位问题思路" class="headerlink" title="定位问题思路"></a>定位问题思路</h3><p>查看需要部署的仓库<br><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A52.png" alt="进入仓库"></p><p><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A51.png" alt="进入github-pages"></p><p><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5.png" alt="查看报错"></p><p>对比阅读 官方文档  <a href="https://docs.github.com/en/rest/deployments/statuses">https://docs.github.com/en/rest/deployments/statuses</a></p><p>state  string  Required<br>The state of the status. When you set a transient deployment to inactive, the deployment will be shown as destroyed in GitHub.</p><p>Can be one of: error, failure, inactive, in_progress, queued, pending, success</p><p>错误在于 due to in progress  上次的部署还没完成，要么取消上次的部署，要么等github挨个处理完</p><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li>查阅问题一步一步确定思路，定位出错点 </li><li>多看官方文档，一针见血</li></ol>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ctrl+F5无法运行</title>
    <link href="/2022/09/30/Ctrl-F5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/09/30/Ctrl-F5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>接上文使用采用实验室K20做深度学习(<a href="https://oowatermelons.github.io/2022/09/23/dl-gpuk20-capacity/">https://oowatermelons.github.io/2022/09/23/dl-gpuk20-capacity/</a>)<br>由于算力限制只能安装  pytorch1.2+python3.6的版本<br><img src="/../img/ctrlf5/ctrl+f5%E4%B8%8D%E8%BF%90%E8%A1%8C.png" alt="环境依赖包"></p><p>但后续出现问题  Ctrl + F5 或者 F5 都无法运行VScode 的python代码，本地尝试了两种方法 </p><ol><li>同个项目内新建python文件，测试快捷键  &#x3D;&gt; 失效</li><li>不同的项目内新建python文件，测试快捷键 &#x3D;&gt; 正常</li></ol><p>初步判断不是编辑器问题，可能是代码依赖包版本的问题</p><h3 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h3><p>按照上面的思路，排除网上很多说修改编辑器的解决办法，集中问题在代码依赖包版本上，查阅官方文档<br>A Visual Studio Code extension with rich support for the Python language (for all actively supported versions of the language:&gt;&#x3D;3.7),including features such as IntelliSense (Pylance),linting,debugging,code navigation,code formatting,refactoring,variable explorer,test explorer,and more!<br>找到原因在于python版本过低，VScode的新Python插件不再支持导致。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>由于Pytorch1.2的限制Python版本最高只能是3.6，所以必须降低Python插件的版本至v2020.8.1<br>具体如图所示：<br><img src="/../img/ctrlf5/ctrl+f5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C.png" alt="更换python插件方法"></p><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li>对比分析，抓住问题重点</li><li>不怕看英语，多看官方文档</li></ol>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VScode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-Join</title>
    <link href="/2022/09/28/mysql-join/"/>
    <url>/2022/09/28/mysql-join/</url>
    
    <content type="html"><![CDATA[<h2 id="MysSQL连接分类"><a href="#MysSQL连接分类" class="headerlink" title="MysSQL连接分类"></a>MysSQL连接分类</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>内连接(inner join)：表a和表b之间的每一行基于对应id列连接后，只取出连接表中匹配的数据，匹配不到的不保留。</li><li>外连接：表a和表b之间的每一行基于对应id列连接后，匹配不到的也会保留，值为NULL。 外连接可以再被划分为左连接和右连接。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>A表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from A;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name<br> 1 |  A1<br> 2 |  A2<br> 3 |  A3<br> 4 |  A4<br></code></pre></td></tr></table></figure><p>B表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from B; // 缺少a_id=4<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | age | a_id <br> 1 |  11 |  1<br> 2 |  22 |  3<br> 3 |  33 |  2<br> 6 |  66 |  6<br></code></pre></td></tr></table></figure><p><strong>内连接（inner join）</strong><br>selcct * from A as a <strong>inner join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a inner join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name | id | age | a_id <br> 1 |  A1  |  1 |  11 |  1<br> 2 |  A2  |  3 |  33 |  2                <br> 3 |  A3  |  2 |  22 |  3<br></code></pre></td></tr></table></figure><p>只会保留有对应匹配的连接表中的行</p><p><strong>外连接（outer join）</strong></p><ul><li>左连接（left outer join）：以左边的表为主表</li><li>右连接（right outer join）：以右边的表为主表</li></ul><p>左连接<br>A表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from A;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name<br> 1 |  A1<br> 2 |  A2<br> 3 |  A3<br> 4 |  A4<br></code></pre></td></tr></table></figure><p>B表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from B; // 缺少a_id=4 故意错位a_id和b.id 的2 和 3<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | age | a_id <br> 1 |  11 |  1<br> 2 |  22 |  3<br> 3 |  33 |  2<br> 6 |  66 |  6<br></code></pre></td></tr></table></figure><hr><p>selcct * from A as a <strong>left join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a left join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name | id | age | a_id <br> 1 |  A1  |  1 |  11 |  1<br> 2 |  A2  |  3 |  33 |  2                <br> 3 |  A3  |  2 |  22 |  3<br> 4 |  A4  |  NULL | NULL | NULL <br></code></pre></td></tr></table></figure><p>右连接</p><hr><p>selcct * from A as a <strong>right join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a right join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id |  name | id | age | a_id |  <br> 1 |  A1   |  1 |  11 |  1   |      <br> 3 |  A2   |  2 |  33 |  3   |                 <br> 2 |  A3   |  3 |  22 |  2   |  <br> NULL| NULL |  6 | 66 |  6   |<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DL-gpu-k20-capacity</title>
    <link href="/2022/09/23/dl-gpuk20-capacity/"/>
    <url>/2022/09/23/dl-gpuk20-capacity/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>计划使用实验室淘汰的Tesla K20显卡跑代码，但训练报错CUDA error: no kernel image is available for execution on the device</p><p>查找资料（<a href="https://developer.nvidia.com/cuda-gpus#collapseOne%EF%BC%89">https://developer.nvidia.com/cuda-gpus#collapseOne）</a> 显示是因为K20算力不够。</p><!-- ![Nvidia显卡算力图](/img/gpu.png) --><p><img src="/../img/gpu.png" alt="Nvidia显卡算力图"></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>一：降低pytorch,测试后发现1.4及以上版本最低算力已经不支持3.5的K20</p><p>二：更换显卡更强硬件</p><p>三：重新编译pytorch参照链接 <a href="https://blog.csdn.net/qq_43051923/article/details/108393510">https://blog.csdn.net/qq_43051923/article/details/108393510</a>  但建议优选方法一，实在不行才选择这个方案。（把精力花在调试代码为先，能pytorch1.2运行，就刚好节省时间）</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
