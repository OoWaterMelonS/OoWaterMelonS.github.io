<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java代码块运行顺序</title>
    <link href="/2022/10/06/Java%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/10/06/Java%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Java代码运行顺序"><a href="#Java代码运行顺序" class="headerlink" title="Java代码运行顺序"></a>Java代码运行顺序</h3><p>类内容（静态变量、静态初始化块） &gt; 实例内容（变量、初始化块、构造器）<br>{static变量、static{}} &gt; {初始变量、初始化块{} &gt; ClassName{}&gt; NormalFunction(){}}</p><p>static{}:从属于类的方法，在有类的，还没有类对象的时候即存在了<br>初始化代码块{}: 初始化类对象优先运行代码块，再运行构造方法<br>ClassName(){}: 对象构造方法，初始化对象运行<br>NormalFunction(){}: 最后运行</p><p>static变量和static{}按照顺序决定代码前后顺序输出结果<br>普通变量 初始化代码块{} 构造方法：</p><ul><li>普通变量 初始化代码块{} 按照顺序决定代码前后顺序输出结果</li><li>有构造方法的话，因为构造方法是最后运行的，所以按照构造方法的结果输出</li></ul><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source.file.TestStatic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br><br>    Test()&#123;<br>        System.out.println(<span class="hljs-string">&quot;construct code block&quot;</span>);<br>        <span class="hljs-comment">// j = 3;</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 输出结果为j = 1</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     System.out.println(&quot;unflagged code block&quot;);</span><br>    <span class="hljs-comment">//     j = 3;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// int j = 1;</span><br><br>    <span class="hljs-comment">// 输出结果为 j= 2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;unflagged code block&quot;</span>);<br>        j = <span class="hljs-number">2</span>;<br>    &#125;<br>    <br><br><br>    <span class="hljs-comment">// 输出结果为i = 20</span><br>    <span class="hljs-comment">// static&#123;</span><br>    <span class="hljs-comment">//     System.out.println(&quot;static code block&quot;);</span><br>    <span class="hljs-comment">//     i = 30;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// static int i = 20;</span><br><br><br>    <span class="hljs-comment">// 输出结果为i = 30</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static code block&quot;</span>);<br>        i = <span class="hljs-number">30</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">codeBlock</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;normal function code block&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        t.codeBlock();<br><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        t2.codeBlock();<br>        System.out.println(Test.i);<br>        System.out.println(t2.j);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">static code block<br>unflagged code block<br>construct code block<br>normal <span class="hljs-keyword">function</span> code block<br>unflagged code blockconstruct code block<br>normal <span class="hljs-keyword">function</span> code block<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java&amp;Python笔试输入模板</title>
    <link href="/2022/10/05/Java&amp;Python%E8%BE%93%E5%85%A5%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/10/05/Java&amp;Python%E8%BE%93%E5%85%A5%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>记录笔试常见的Java笔试的输入代码模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaSystemIn</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 实例一：基于Scanner</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(sc1.nextInt());<br>        System.out.println(sc1.nextDouble());<br>        System.out.println(sc1.nextFloat());<br>        <span class="hljs-comment">// 读取下一行</span><br>        System.out.println(sc1.nextLine());<br>        sc1.close();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 实例二：</span><br><span class="hljs-comment">         * 利用new BufferedInputStream加快速度</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(System.in));<br>        System.out.println(sc2.nextInt());<br>        System.out.println(sc2.nextDouble());<br>        System.out.println(sc2.nextFloat());<br>        <span class="hljs-comment">// 读取下一行</span><br>        System.out.println(sc2.nextLine());<br>        <br>        sc2.close();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 示例三：</span><br><span class="hljs-comment">         * 利用字符输入流</span><br><span class="hljs-comment">         * PS 需要抛出异常</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        System.out.println(br.readLine());<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>        System.out.println(a);<br>        <br>        <span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Float.parseFloat(br.readLine());<br>        System.out.println(b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>记录笔试常见的Python笔试的输入代码模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    实例一：</span><br><span class="hljs-string">    题目需要单行输入一串数字  例如接受 1 2 3</span><br><span class="hljs-string">    input()将查询用户的输入，并读取一行用户输入</span><br><span class="hljs-string">    .split()会将输入拆分为“单词”列表</span><br><span class="hljs-string">    map(int, ...)会在每个单词上调用int ，它会懒惰地调用int （尽管这在这里并不重要）； </span><br><span class="hljs-string">    a, b, c = ...将把表达式分解成两个元素，并将第一个分配给a ，第二个分配给b, 第三个分配给c</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    a,b,c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    实例二：</span><br><span class="hljs-string">    直接将单行输入的数字一次转换后放入链表</span><br><span class="hljs-string">    input()将查询用户的输入，并读取一行用户输入</span><br><span class="hljs-string">    .split()会将输入拆分为“单词”列表</span><br><span class="hljs-string">    int(i) for i in list 将单词链表转换为整型链表</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    lists1 = [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    <br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    实例三：</span><br><span class="hljs-string">    题目需要单行输入一串数字  例如接受 1 2 3</span><br><span class="hljs-string">    input()将查询用户的输入，并读取一行用户输入</span><br><span class="hljs-string">    .split()会将输入拆分为“单词”列表</span><br><span class="hljs-string">    map(int, ...)会在每个单词上调用int ，它会懒惰地调用int （尽管这在这里并不重要）； </span><br><span class="hljs-string">    list(..)部分强制转换map对象结果为list</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    lists2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>    <span class="hljs-built_in">print</span>(solution(lists2))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改进型Clock置换算法</title>
    <link href="/2022/10/03/%E6%94%B9%E8%BF%9B%E5%9E%8BClock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2022/10/03/%E6%94%B9%E8%BF%9B%E5%9E%8BClock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如分页存储系统页大小为4KB,字节编址，系统给进程P分配两个固定页框，并采用改进型Clock置换算法，进程P的页表的部分内容如下：</p><table><thead><tr><th>页号</th><th>页框号</th><th>存在位（1：存在 0：不存在）</th><th>访问位（1：访问 0：为访问）</th><th>修改位 （1：修改，0：未修改）</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>2</td><td>20H</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>60H</td><td>1</td><td>1</td><td>0</td></tr><tr><td>4</td><td>80H</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>若P访问虚拟地址为02A01H的存储单位，则经地址变换为得到的物理地址是( C )。<br>A. 00A01H  B. 20A01H  C. 60A01H  D. 80A01H</p><h3 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识</h3><p>进制转换<br>内存管理的地址转换<br>页面置换算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p><strong>虚拟地址（逻辑地址）</strong><br>虚拟地址02A01H &#x3D; 页号+页内偏移量（和内存页大小统一）。<br>页面大小为4KB&#x3D;$2^{12}$B，对应虚拟地址为02A01H。<br>因为页面大小和业内偏移量相同大小,所以02H为页号。</p><p><img src="/../img/OS/Clock%20replacement%20algorithm/%E6%94%B9%E8%BF%9B%E5%9E%8BCLock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.drawio.png" alt="映射关系举例"></p><p>结合背景中的图标可知，02H对应的页框（内存中的一格）号为20H。</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>因为题干给出要求，内存中固定分配给进程两个页框，同时页号00H，01H已经暂用内存两个页框，所以需要执行页从内存的换入换出。</p><p><strong>页面置换算法（6种）</strong><br><a href="https://www.cnblogs.com/wingsless/p/12295246.html">参照链接一</a></p><ul><li>最佳（Optimal,OPT）置换算法</li><li>先进先出(FIFO)页面置换算法</li><li>最近最久未使用（LRU）置换算法</li><li>随机置换</li><li>时钟置换算法 </li><li>改进时钟置换算法</li></ul><p><strong>时钟置换算法</strong><br><a href="https://www.cnblogs.com/hzxscyq/p/5373760.html">参考链接二</a><br>存在位(resident bit): 对于一个页面是否有物理页与其对应，如果有就为1。<br>修改位(dirty bit)：判断页面 是否被修改过。<br>引用位(clock&#x2F;reference bit)：页面是否有过对它的引用。</p><ol><li>由于20H存在位是0，60H和80H两个页框连续且存在,所以符合题目要求</li><li>根据改进时钟置换算法 60H(1,0)的优先级 &gt; 80H(1,1),所以虚拟地址02A01H转为位实际内存物理地址位60A01H。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>H&#x3D;&gt;16进制   B&#x3D;&gt;2进制   D&#x3D;&gt;10进制  O&#x3D;&gt;8进制</li><li>逻辑地址和物理地址的地址转换 ，基于页表作为中间映射。</li><li>基本分页存储管理的页面置换算法。</li><li>时钟置换算法的处理流程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分页存储置换算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github使用总结</title>
    <link href="/2022/10/03/github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/03/github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="github工作流笔记"><a href="#github工作流笔记" class="headerlink" title="github工作流笔记"></a>github工作流笔记</h3><p>步骤繁杂，却也是做开源必须遵循的原则，避免污染代码。<br>主要供自己学习，查询。</p><p>注意三个代码的三个过程</p><ul><li>remote: 远程github仓库的代码</li><li>Local: 本地仓库中的代码</li><li>Disk: 本地磁盘，真正被程序员修改的代码</li></ul><h4 id="操作步骤（开源贡献或公司项目）"><a href="#操作步骤（开源贡献或公司项目）" class="headerlink" title="操作步骤（开源贡献或公司项目）"></a>操作步骤（开源贡献或公司项目）</h4><p>第一步：从remote server下载源码到Local，第一次clone后，remote ,Disk内容和Locald都是相同版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/example/xxxxx.git<br></code></pre></td></tr></table></figure><p>第二步：避免污染源代码，基于Local复制一份branch为 my-feature。此时Local会有两个版本main(master branch)和my-feature。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout  -b my-feature<br></code></pre></td></tr></table></figure><p>第三步：切换为my-feature,编辑器编辑此branch的源码。查看Disk上的代码的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><p>第四步：将Disk修改了的内容，告知Local git。这些内容会被放到一个暂缓区，尚未修改Local git的my-feature分支的源码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;changed_file&gt;<br></code></pre></td></tr></table></figure><p>第五步：确定代码没问题后或多次add提交后，将暂存区中的源提交到Local git。此时Local git中的my-feature branch的源码是最新修改过的版本。main branch没变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;new xxxx change&quot;</span><br></code></pre></td></tr></table></figure><p>第六步：将Local git的my-feature push到远程服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin my-feature<br></code></pre></td></tr></table></figure><p>第七步：可能github上有其他贡献者,整合了新的更改在github的main中（即此时Local的main和github的main也可能不同）。<br>为了解决这个问题，将disk切换为main，再把Local和Disk都同步为最新的main</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br>git pull origin master<br></code></pre></td></tr></table></figure><p>第八步：Disk切换为my-feature,在my-feature分支下,将Local中的新的main和my-feature合并。采用rebase（优先接受main中的改变，再接受my-feature中的修改）<br>rebase 可能出现rebase conflict,需要手动修改my-feature,再add commit来适配。<br>也可以采用merge，但针对开源代码，优先考量他人的代码是正确的（毕竟有人专门审核）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase main<br></code></pre></td></tr></table></figure><p>第九步: Local中上一步得到的结果，相当于在最新的github的main的基础上做了修改，将本地的branch(强行单人开发的可以-f，多人协作避免使用)push到github。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f origin my-feature<br></code></pre></td></tr></table></figure><p>第十步: 告诉项目主人，将my-feature的分支整合到github中的main中去,这可以是在github的网页操作了，不用在本地命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">New pull request<br></code></pre></td></tr></table></figure><p>第十一步： 项目主人，审查代码后，整合你的my-feature代码到main中<br>Squash and merge(将这个分支上的所有改变，合并成一个改变)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Squash and merge <br></code></pre></td></tr></table></figure><p>第十二步：github网页端删除my-feature，Local切换到main,删除my-feature,之后同步下来最新的到main中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D my-feature<br>git pull origin master<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如此繁琐操作的核心，在于更改尽量在my-feature中，同时需要考虑同步时候，和最新的main的conflict.</li><li>后续在工作中一步一步的实践，理解，向着开源学习。</li></ol>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程笔记一</title>
    <link href="/2022/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2022/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>Java个人学习笔记</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>甲方项目提出前端页面增加一个功能，需要将数据库的100万（百万两级）条数据，在限定8秒之内（用户体验）导出到指定数量的Excel表.<br>采用方案一：C++或者golang或者C等等，但是后端技术栈是SpringClound微服务，这样胶水式操作不易维护。<br>采用方案二：Java操作，采用单线程一行一行的读取后写入Excel，那大概率会超时。<br>采用方案三：使用Java多线程。</p><p>分析项目需求 Java多线程不仅是实际项目需要的，还是面试笔试重点。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><a href="https://blog.51cto.com/u_15773567/5722534#:~:text=%E7%BA%BF%E7%A8%8B%E6%98%AF%20%E2%80%8B%20%E2%80%8B%20CPU%20%E2%80%8B%20%E2%80%8B%20%E2%80%8B%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83,%EF%BC%8C%E7%94%B1%E7%BA%BF%E7%A8%8B%E2%80%8B%20%E2%80%8BID%E2%80%8B%20%E2%80%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E5%90%88%E5%92%8C%E6%A0%88%E7%BB%84%E6%88%90%E3%80%82%20%E8%BF%9B%E7%A8%8B%E7%94%B1%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A%20%E2%80%8B%20%E2%80%8BLinux%E2%80%8B%20%E2%80%8B%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%87%AA%E7%84%B6%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%82">进程</a>可以理解为运行的一个程序（QQ,微信,网易音乐,Word,运行中的SpringBoot jar包），由<strong>PCB（进程控制块）、程序段、数据段</strong>组成。可以查看任务管理器重的进程如下<br><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B.png" alt="进程示意图"><br>一个进程在OS中的资源，包含了CPU、内存、磁盘、网络、I&#x2F;O等等。<br>OS支持多任务模型，会有类似上图 可以同时运行多个程序，对比<a href="https://www.zditect.com/main/os/multiprogramming-vs-multitasking.html">多道程序概念</a>。</p><p>每个进程生命周期都会有就绪态，运行态，阻塞态，新建态PCB，终止态五种状态，但前三种为基本态，时间占比较长。</p><p>一个进程至少包含一个线程（主线程）。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程的运行开销重，为了更好的使多道程序并发执行。</p><ol><li><p>线程是CPU使用的基本单元，<strong>由线程ID、程序计数器、寄存器集合和栈组成</strong>。</p></li><li><p>进程由一个或多个线程组成：创建一个进程会伴随着创建一个线程（主线程）</p></li><li><p>调度切换：<a href="https://blog.51cto.com/u_15773567/5722534#:~:text=%E7%BA%BF%E7%A8%8B%E6%98%AF%20%E2%80%8B%20%E2%80%8B%20CPU%20%E2%80%8B%20%E2%80%8B%20%E2%80%8B%20%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83,%EF%BC%8C%E7%94%B1%E7%BA%BF%E7%A8%8B%E2%80%8B%20%E2%80%8BID%E2%80%8B%20%E2%80%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E5%90%88%E5%92%8C%E6%A0%88%E7%BB%84%E6%88%90%E3%80%82%20%E8%BF%9B%E7%A8%8B%E7%94%B1%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A%20%E2%80%8B%20%E2%80%8BLinux%E2%80%8B%20%E2%80%8B%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%87%AA%E7%84%B6%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%82">线程上下问切换比进程上下文切换快</a></p></li></ol><p>创建进程：需要为进程划分一整块完整内存，需要大量初始化操作，比如要把内存分段（堆栈、正文区等）。</p><p>创建线程：只需要确定PC指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。</p><p><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.jpg" alt="多线程进程"></p><p>一个进程可以划分为多线程（并发）的重要前提：通过线程之间的通信，保证数据<strong>原子性、可见性、有序性</strong></p><h4 id="原子性（atom）"><a href="#原子性（atom）" class="headerlink" title="原子性（atom）"></a>原子性（atom）</h4><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。</p><p><strong>保证原子性</strong></p><ol><li>synchronized 关键字定义同步块或者同步方法保障原子性</li><li>Lock接口保证原子性</li><li>Atomic类型保障原子性</li></ol><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程修改了共享变量的值，其他线程能够看到修改的值<br>JMM通过共享内存实现线程通信</p><p>volatile变量和普通变量<br>volatile变量强行保证了被一个线程修改的变量的数据变量，被刷入内存。代码是一样的，所以其他线程也有volatile变量，但此时他们的volatile变量不生效</p><p><strong>保证可见性</strong></p><ol><li>volatile 关键字标记内存屏障保证可见性</li><li>synchronized 关键字定义同步代码块或者同步方法保障可见性</li><li>Lock接口保障可见性</li><li>Atomic类型保障可见性</li><li>final关键字保障可见性</li></ol><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>程序执行的顺序按照代码的先后顺序执行<br>JVM存在指令重排，无关系的数据之间的初始，是没有顺序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ......<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>        a = a+<span class="hljs-number">2</span>;<br>        b = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(b)&#123;<br>            a = a+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上述有多个线程在执行，因为a和b之间在A中执行是无关联的，不同于B。 那么在A中经过指令重排序，可能先执行b &#x3D; true;当还没执行a&#x3D;a+2;时。另一个线程读取到b的true状态,拿着还是a&#x3D;0;的情况就开始做a&#x3D;a+1;<br>解决办法：使用volitile关键字 <code>public int volitile a;</code></p><h3 id="JMM-Java-Memory-Model，Java内存模型"><a href="#JMM-Java-Memory-Model，Java内存模型" class="headerlink" title="JMM(Java Memory Model，Java内存模型)"></a>JMM(Java Memory Model，Java内存模型)</h3><p><img src="/../img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JMM内存模型"></p><p>还有部分笔记后续补上，先赶项目去了。。。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo本地和github文件都更新，但主页却没更新问题</title>
    <link href="/2022/09/30/Hexo%E6%9C%AC%E5%9C%B0%E5%92%8Cgithub%E6%96%87%E4%BB%B6%E9%83%BD%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BD%86%E4%B8%BB%E9%A1%B5%E5%8D%B4%E6%B2%A1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/30/Hexo%E6%9C%AC%E5%9C%B0%E5%92%8Cgithub%E6%96%87%E4%BB%B6%E9%83%BD%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BD%86%E4%B8%BB%E9%A1%B5%E5%8D%B4%E6%B2%A1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>基于Hexo,今天打算更新一篇解决Python调试博客，但部署在github的个人主页不更新页面。<br>逐步一步一步查阅问题：</p><ol><li>hexo s 本地显示正常</li><li>hexo clean | hexo g 正常</li><li>hexo d 上传github显示正常，文件是已经更新了的版本</li><li>浏览器没显示正常</li></ol><p>从上可以发现是3和4步之间出现问题，对应查阅Github将上传的静态文件是否自动部署成功。<br>解决办法是可能只有干等</p><h3 id="定位问题思路"><a href="#定位问题思路" class="headerlink" title="定位问题思路"></a>定位问题思路</h3><p>查看需要部署的仓库<br><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A52.png" alt="进入仓库"></p><p><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A51.png" alt="进入github-pages"></p><p><img src="/../img/%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%9B%B4%E6%96%B0/%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5.png" alt="查看报错"></p><p>对比阅读 官方文档  <a href="https://docs.github.com/en/rest/deployments/statuses">https://docs.github.com/en/rest/deployments/statuses</a></p><p>state  string  Required<br>The state of the status. When you set a transient deployment to inactive, the deployment will be shown as destroyed in GitHub.</p><p>Can be one of: error, failure, inactive, in_progress, queued, pending, success</p><p>错误在于 due to in progress  上次的部署还没完成，要么取消上次的部署，要么等github挨个处理完</p><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li>查阅问题一步一步确定思路，定位出错点 </li><li>多看官方文档，一针见血</li></ol>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ctrl+F5无法运行</title>
    <link href="/2022/09/30/Ctrl-F5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/09/30/Ctrl-F5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>接上文使用采用实验室K20做深度学习(<a href="https://oowatermelons.github.io/2022/09/23/dl-gpuk20-capacity/">https://oowatermelons.github.io/2022/09/23/dl-gpuk20-capacity/</a>)<br>由于算力限制只能安装  pytorch1.2+python3.6的版本<br><img src="/../img/ctrlf5/ctrl+f5%E4%B8%8D%E8%BF%90%E8%A1%8C.png" alt="环境依赖包"></p><p>但后续出现问题  Ctrl + F5 或者 F5 都无法运行VScode 的python代码，本地尝试了两种方法 </p><ol><li>同个项目内新建python文件，测试快捷键  &#x3D;&gt; 失效</li><li>不同的项目内新建python文件，测试快捷键 &#x3D;&gt; 正常</li></ol><p>初步判断不是编辑器问题，可能是代码依赖包版本的问题</p><h3 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h3><p>按照上面的思路，排除网上很多说修改编辑器的解决办法，集中问题在代码依赖包版本上，查阅官方文档<br>A Visual Studio Code extension with rich support for the Python language (for all actively supported versions of the language:&gt;&#x3D;3.7),including features such as IntelliSense (Pylance),linting,debugging,code navigation,code formatting,refactoring,variable explorer,test explorer,and more!<br>找到原因在于python版本过低，VScode的新Python插件不再支持导致。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>由于Pytorch1.2的限制Python版本最高只能是3.6，所以必须降低Python插件的版本至v2020.8.1<br>具体如图所示：<br><img src="/../img/ctrlf5/ctrl+f5%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C.png" alt="更换python插件方法"></p><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li>对比分析，抓住问题重点</li><li>不怕看英语，多看官方文档</li></ol>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VScode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-Join</title>
    <link href="/2022/09/28/mysql-join/"/>
    <url>/2022/09/28/mysql-join/</url>
    
    <content type="html"><![CDATA[<h2 id="MysSQL连接分类"><a href="#MysSQL连接分类" class="headerlink" title="MysSQL连接分类"></a>MysSQL连接分类</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>内连接(inner join)：表a和表b之间的每一行基于对应id列连接后，只取出连接表中匹配的数据，匹配不到的不保留。</li><li>外连接：表a和表b之间的每一行基于对应id列连接后，匹配不到的也会保留，值为NULL。 外连接可以再被划分为左连接和右连接。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>A表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from A;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name<br> 1 |  A1<br> 2 |  A2<br> 3 |  A3<br> 4 |  A4<br></code></pre></td></tr></table></figure><p>B表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from B; // 缺少a_id=4<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | age | a_id <br> 1 |  11 |  1<br> 2 |  22 |  3<br> 3 |  33 |  2<br> 6 |  66 |  6<br></code></pre></td></tr></table></figure><p><strong>内连接（inner join）</strong><br>selcct * from A as a <strong>inner join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a inner join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name | id | age | a_id <br> 1 |  A1  |  1 |  11 |  1<br> 2 |  A2  |  3 |  33 |  2                <br> 3 |  A3  |  2 |  22 |  3<br></code></pre></td></tr></table></figure><p>只会保留有对应匹配的连接表中的行</p><p><strong>外连接（outer join）</strong></p><ul><li>左连接（left outer join）：以左边的表为主表</li><li>右连接（right outer join）：以右边的表为主表</li></ul><p>左连接<br>A表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from A;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name<br> 1 |  A1<br> 2 |  A2<br> 3 |  A3<br> 4 |  A4<br></code></pre></td></tr></table></figure><p>B表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from B; // 缺少a_id=4 故意错位a_id和b.id 的2 和 3<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | age | a_id <br> 1 |  11 |  1<br> 2 |  22 |  3<br> 3 |  33 |  2<br> 6 |  66 |  6<br></code></pre></td></tr></table></figure><hr><p>selcct * from A as a <strong>left join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a left join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id | name | id | age | a_id <br> 1 |  A1  |  1 |  11 |  1<br> 2 |  A2  |  3 |  33 |  2                <br> 3 |  A3  |  2 |  22 |  3<br> 4 |  A4  |  NULL | NULL | NULL <br></code></pre></td></tr></table></figure><p>右连接</p><hr><p>selcct * from A as a <strong>right join</strong> B as b <strong>on</strong> a.id&#x3D; b.a_id;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">selcct * from A as a right join B as b on a.id= b.a_id;<br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">id |  name | id | age | a_id |  <br> 1 |  A1   |  1 |  11 |  1   |      <br> 3 |  A2   |  2 |  33 |  3   |                 <br> 2 |  A3   |  3 |  22 |  2   |  <br> NULL| NULL |  6 | 66 |  6   |<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DL-gpu-k20-capacity</title>
    <link href="/2022/09/23/dl-gpuk20-capacity/"/>
    <url>/2022/09/23/dl-gpuk20-capacity/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>计划使用实验室淘汰的Tesla K20显卡跑代码，但训练报错CUDA error: no kernel image is available for execution on the device</p><p>查找资料（<a href="https://developer.nvidia.com/cuda-gpus#collapseOne%EF%BC%89">https://developer.nvidia.com/cuda-gpus#collapseOne）</a> 显示是因为K20算力不够。</p><!-- ![Nvidia显卡算力图](/img/gpu.png) --><p><img src="/../img/gpu.png" alt="Nvidia显卡算力图"></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>一：降低pytorch,测试后发现1.4及以上版本最低算力已经不支持3.5的K20</p><p>二：更换显卡更强硬件</p><p>三：重新编译pytorch参照链接 <a href="https://blog.csdn.net/qq_43051923/article/details/108393510">https://blog.csdn.net/qq_43051923/article/details/108393510</a>  但建议优选方法一，实在不行才选择这个方案。（把精力花在调试代码为先，能pytorch1.2运行，就刚好节省时间）</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
